-- PARA REALIZAR INICIO DE SESIÓN --
Con estos pasos, si ya hay usuarios en el sistema, ya pueden generar tokens de acceso y iniciar sesión.

1. Agregar lo siguiente en "config/settings.py"
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
}

2. Dentro de api/urls.py importar
from django.urls import path
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

3. Agregar las siguiente rutas al proyecto
urlpatterns = [
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]

-- CREAR UN REGISTRO DE USUARIOS CON ACTIVAR CUENTA -- 
Para crear un registro de usuarios en la api, se necesita hacer uso de un Serializer, este es un validador que
convierte los JSON enviados desde el frontend en un objeto de python verificando si son correctos en el proceso.
Esto es indispensable para guardar cosas en la base de datos.

Por otra parte, se hace uso de sendgrid para enviar correos y validar los mails de los usuarios, esto funciona de
forma de que cuando un usuario se registra, la cuenta se registra y queda marcada como "Inactiva", django envía correo
de activación con sendgrid, el usuario confirma y la cuenta se cambia a "activa".

1. Para configurar la api de sendgrid hay que tenerla configurada desde la página.

2. Dentro del archivo .env añadir las siguientes variables:
SENDGRID_API_KEY=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
EMAIL_HOST_USER=apikey
DEFAULT_FROM_EMAIL=dragondelbastiondelnorte@gmail.com

3. En config/settings.py colocar
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.sendgrid.net'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = config('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = config('SENDGRID_API_KEY')
DEFAULT_FROM_EMAIL = config('DEFAULT_FROM_EMAIL')

4. Crear archivo dentro de api llamado "signals.py"

5. Importar las siguientes cosas signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from django.core.mail import send_mail
from django.conf import settings
from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode
from django.utils.encoding import force_bytes

6. Pegar el siguiente código
@receiver(post_save, sender=User)
def send_verification_email(sender, instance, created, **kwargs):
    if created and not instance.is_active:
        # Generar token y uid
        token = default_token_generator.make_token(instance)
        uid = urlsafe_base64_encode(force_bytes(instance.pk))

        # Construir URL de verificación (apuntando a tu frontend)
        # El frontend tomará el uid y token y hará una petición a la API
        verification_url = f"http://localhost:3000/activate/{uid}/{token}/"

        # Enviar email
        subject = 'Activa tu cuenta'
        message = f'Hola {instance.username},\n\n' \
                  f'Por favor, haz clic en el siguiente enlace para activar tu cuenta:\n' \
                  f'{verification_url}\n\n' \
                  f'Gracias.'
        send_mail(subject, message, settings.DEFAULT_FROM_EMAIL, [instance.email])

7. Crear archivo dentro de api llamado "serializers.py"

8. Importar lo siguiente en el archivo
from rest_framework import serializers, validators
from django.contrib.auth.models import User
Esto es para crear serializers y verificar campos, se trae el modelo de User de defecto de django.

9. Añadir el siguiente código [Comentado en la aplicación]
# Serializer para registro de usuarios
class RegisterSerializer(serializers.ModelSerializer):
    class Meta:
        # Definimos el modelo y los campos que se van a utilizar
        model = User
        fields = ('username', 'password', 'email', 'first_name', 'last_name')
        # Configuramos los atributos adicionales para los campos
        extra_kwargs = {
            "password": {"write_only": True},
            "email": {
                # Añadimos un validador para asegurar que el email es único, requerido y no puede estar en blanco
                "required": True,
                "allow_blank": False,
                "validators": [
                    validators.UniqueValidator(
                        User.objects.all(), "Ya hay una cuenta asociada a ese email." 
                    )
                ]
            }
        }

    # Método para crear un nuevo usuario con los datos validados
    def create(self, validated_data):
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data['email'],
            password=validated_data['password'],
            first_name=validated_data.get('first_name', ''),
            last_name=validated_data.get('last_name', ''),
            is_active=False  # El usuario se crea como inactivo hasta que verifique su email
        )
        return user

10. Ir a api/views.py e importar
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import AllowAny
from .serializers import RegisterSerializer
from django.contrib.auth.models import User
from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_decode
from django.utils.encoding import force_str

9. Agregar vista de registro
Las vistas están protegidas por los tokens de autentificación, por lo que AllowAny permite que todos los usuarios, 
no solo los que han iniciado sesión puedan entrar.
@api_view(['POST']) # Solo permite solicitudes POST
@permission_classes([AllowAny]) # Permite que cualquiera pueda acceder a esta vista
# Vista para registrar un nuevo usuario
def register_view(request):
    # Utiliza el serializer de registro de usuarios para validar y guardar los datos del usuario
    serializer = RegisterSerializer(data=request.data)
    # Si los datos son válidos, guarda el nuevo usuario y devuelve un mensaje de éxito
    if serializer.is_valid():
        serializer.save()
        return Response({"message": "Usuario creado con éxito"}, status=201)
    # Si los datos no son válidos, devuelve los errores de validación
    return Response(serializer.errors, status=400)

10. Agregar vista para activar cuenta
@api_view(['POST']) # Solo permite solicitudes POST
@permission_classes([AllowAny]) # Permite que cualquiera pueda acceder a esta vista
# Vista para activar la cuenta de un usuario mediante un enlace con token
def activate_account_view(request, uidb64, token):
    try:
        # Decodifica el uid y obtiene el usuario correspondiente
        uid = force_str(urlsafe_base64_decode(uidb64))
        user = User.objects.get(pk=uid)
    except (TypeError, ValueError, OverflowError, User.DoesNotExist):
        user = None
        
    # Verifica el token y activa la cuenta si es válido
    if user is not None and default_token_generator.check_token(user, token):
        user.is_active = True # Activa el usuario
        user.save() # Guarda los cambios
        return Response({"message": "Cuenta activada exitosamente."}, status=200)
    else:
        return Response({"error": "El enlace de activación es inválido."}, status=400)

11. Agregar rutas al modelo
path('register/', register_view, name='register'),
path('activate/<str:uidb64>/<str:token>/', activate_account_view, name='activate'),

-- MANTENER CONECTADO --

1. Pegar lo siguiente en el settings












